# Práctica 3. Balanceo de carga en un sitio web

> Alumno: Miguel Ángel Fernández Gutiérrez

## Objetivos

En esta práctica, configuraremos SWAP3, un nuevo servidor, como balanceador de carga de los servidores SWAP1 y SWAP2. Por tanto, deberemos realizar las peticiones a SWAP3, pues es la encargada de repartir el tráfico. De este modo conseguimos servir más peticiones en conjunto, y de forma más eficiente. Analizaremos diversas formas de balanceo con diversos balanceadores, así como si el balanceo es útil (si, en efecto, mejora las prestaciones de nuestro cluster).

Introducimos la configuración de red de SWAP3.

| Nombre de VM | SWAP1 | SWAP2 | SWAP3 |
| --- | --- | --- | --- |
| Hostname | `m1-mianfg` | `m2-mianfg` | `m3-mianfg` |
| IP `enp0s3` (NAT) | 192.168.0.3/24 | 192.168.0.4/24 | 192.168.0.5/24 |
| IP `enp0s8` (Host-Only) | 192.168.13.10/24 | 192.168.13.20/24 | 192.168.13.30/24 |
| Nombre usuario | `mianfg` | `mianfg` | `mianfg` |
| Contraseña | `Swap1234` | `Swap1234` | `Swap1234` |

## Preliminares

Vamos a clonar cualquiera de las dos máquinas para crear SWAP3, con los parámetros que aparecen antes (modificar `/etc/hostname` y cambiar la configuración de red con `netplan`). Finalmente, desactivamos Apache mediante los comandos:

```
mianfg@m3-mianfg$ sudo systemctl stop apache2
mianfg@m3-mianfg$ sudo systemctl disable apache2
```

## Configuración de balanceadores

### Nginx

> En este apartado:
>
> * Configuración de un balanceador de carga con Nginx
> * Tipos de balanceo: round-robin, round-robin con ponderación, hash IP, marcar un servidor en _down_ (sin balanceo), keepalive timeout...

Comenzamos instalando y activando Nginx. Basta hacer:

```
mianfg@m3-mianfg$ sudo apt-get install nginx
mianfg@m3-mianfg$ sudo service nginx start
mianfg@m3-mianfg$ sudo service nginx status
```

Vemos con `status` que Nginx está activo:

![3-01](./img/3-01.png)

Por defecto, Nginx está configurado para funcionar como servidor web. Para ello, basta editar el archivo `/etc/nginx/nginx.conf` y comentar la línea

```
include /etc/nginx/sites-enabled/*;
```

Lo vemos en la captura a continuación:

![3-02](./img/3-02.png)

Modificamos la configuración para añadir los ajustes del balanceador. Basta crear el archivo `/etc/nginx/conf.d/default.conf` con el siguiente contenido:

```
upstream balanceo_mianfg {
    server 192.168.13.10;
    server 192.168.13.20;
}

server {
    listen 80;
    server_name balanceador_mianfg;
  
    access_log /var/log/nginx/balanceador_mianfg.access.log;
    error_log /var/log/nginx/balanceador_mianfg.error.log;
    root /var/www/;
    
    location / {
        proxy_pass http://balanceo_mianfg;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
```

![3-03](./img/3-03.png)

Para aplicar los cambios, reiniciamos el servicio `nginx` con `service`. Antes de hacer esto, podemos hacer uso del comando `nginx -t` (con privilegios _sudo_) para comprobar que no hay ningún fallo en la configuración. Esto es especialmente útil si queremos disminuir al máximo el _downtime_.

![3-04](./img/3-04.png)

Una vez hecho esto, podemos hacer `curl` desde el host para comprobar que, en efecto, el balanceo está teniendo lugar:

![3-05](./img/3-05.png)

Veamos a continuación otras formas de balancear el tráfico. Para poder modificar la configuración, en todos los casos necesitamos modificar el archivo `/etc/nginx/conf.d/default.conf` y reiniciar `nginx` (pudiendo ejecutar `nginx -t` para realizar comprobaciones). Omitimos esto para no ser repetitivos en cada apartado.

> Todos los ajustes se encuentran en la documentación de Nginx, en [este enlace](http://nginx.org/en/docs/http/ngx_http_upstream_module.html).

#### Round-robin

La configuración por defecto de Nginx (lo que justo hemos configurado) es _round-robin_, es decir, comenzamos por el primer elemento y vamos hasta el último, volviendo luego a comenzar por el primero. En nuestro caso, el servidor alternará entre SWAP1 y SWAP2 al recibir las peticiones.

#### Round-robin con ponderación

Podemos ponderar cada uno de los servidores a la hora de realizar el _round-robin_. Si tenemos $n$ servidores, cada uno con ponderación $P_i$, las peticiones se dirigirán al servidor $i$-ésimo $P_i$ de cada $\sum_{i=1}^n P_i$ veces.

La configuración en Nginx pasa por añadir el parámetro `weight` al lado de cada servidor. Haremos que SWAP1 tenga un peso de 1 y SWAP2 tenga un peso de 2. De cada 3 peticiones, 1 irá a SWAP1 y 2 irán a SWAP2.

```
upstream balanceo_mianfg {
    server 192.168.13.10 weight=1;
    server 192.168.13.20 weight=2;
}

# ...
```

![3-06](./img/3-06.png)

#### IP hashing

Otra alternativa es hacer que una IP siempre vaya a parar al mismo servidor. Esto se logra con _hashing_, y se configura de forma sencilla.

```
upstream balanceo_mianfg {
    ip_hash;
    server 192.168.13.10;
    server 192.168.13.20;
}

# ...
```

![3-07](./img/3-07.png)

Dado que nuestro host tiene la misma IP, vemos que al hacer `curl` siempre recibimos las peticiones del mismo servidor.

#### Keepalive timeout

Mediante el uso de la directiva `keepalive_timeout`, indicamos cuánto debe esperar el servidor para recibir peticiones del cliente; en otras palabras, indicamos el número de segundos que una conexión se mantendrá abierta. La recomendación de los desarrolladores de Nginx es mantenerlas abiertas entre 6 y 10 segundos. Si este valor es demasiado alto, el servidor puede congestionarse fácilmente y agotar la RAM. Configuraremos un _keepalive timeout_ de 6s.

```
upstream balanceo_mianfg {
    server 192.168.13.10;
    server 192.168.13.20;
    keepalive_timeout 6;
}

# ...
```

![3-08](./img/3-08.png)

Nótese que estamos volviendo a realizar _round-robin_ (por defecto).

#### Marcar servidor como `down`

En caso de que queramos realizar mantenimiento, podemos marcar un servidor como _down_ (inactivo). De este modo, las peticiones se dirigirán al resto de servidores. En nuestro caso, al tener solo dos, todas las peticiones irán a SWAP1 (marcamos SWAP2 como _down_).

```
upstream balanceo_mianfg {
    server 192.168.13.10;
    server 192.168.13.20 down;
}

# ...
```

![3-09](./img/3-09.png)

#### Una configuración más compleja

Veamos un ejemplo más complejo de uso. Supongamos que tenemos un servidor SWAP4 cuya interfaz `enp0s8` tiene IP 192.168.13.40/24. SWAP3 tiene la siguiente configuración de balanceador:

```
upstream balanceo_mianfg {
    least_conn;
    server 192.168.13.10 max_fails=7;
    server 192.168.13.20;
    server 192.168.13.40 backup;
    sticky cookie srv_id expires=1h;
}

# ...
```

* `least_conn` indica que la petición será enviada al servidor con el menor número de conexiones activas.
* `max_fails` configura el número máximo de intentos fallidos de comunicación con el servidor antes de considerarlo inactivo por un periodo específico de tiempo. En concreto, si el servidor recibe al menos `max_fails` peticiones incorrectas en `fail_timeout` segundos, se mantendrá inactivo durante `fail_timeout` segundos. Dado que hemos configurado SWAP1 con `max_fails=7` y que por defecto es `fail_timeout=10`, SWAP1 se mantendrá inactivo durante 10s si recibe al menos 7 peticiones fallidas en 10s.
* `backup` configura un servidor _backup_, que se mantendrá inactivo hasta que los servidores principales no estén disponibles.
* `sticky cookie` añade una cookie de sesión a la primera respuesta que identifica el servidor que ha respondido. La siguiente petición al balanceador incluirá tal cookie y Nginx responderá con el mismo servidor. La cookie se llamará `srv_id` y tendrá un tiempo de expiración de 1h. Este es el método de persistencia más simple.

### HAProxy

> En este apartado:
>
> * Configuración de un balanceador de carga con Nginx
> * Tipos de balanceo: round-robin, round-robin con ponderación, hash IP, marcar un servidor en _down_ (sin balanceo), keepalive timeout...

Para configurar HAProxy, primero procederemos a desactivar el servicio `nginx` para luego instalar y activar `haproxy`.


```
mianfg@m3-mianfg$ sudo service nginx stop
mianfg@m3-mianfg$ sudo systemctl disable nginx
mianfg@m3-mianfg$ sudo apt-get install haproxy
mianfg@m3-mianfg$ sudo service haproxy start
mianfg@m3-mianfg$ sudo service haproxy status
```

Vemos con `status` que `haproxy` está activo:

![3-10](./img/3-10.png)

Procedemos a la primera configuración. Para ello, modificamos el archivo `/etc/haproxy/haproxy.cfg` e insertamos:

```
frontend http-in
    bind *:80
    default_backend balanceo_mianfg

backend balanceo_mianfg
    server m1    192.168.13.10:80
    server m2    192.168.13.20:80
```

![3-11](./img/3-11.png)

Veamos qué hemos hecho, y adentrémonos en las configuraciones de HAProxy. Procederemos como con Nginx: realizaremos unas configuraciones básicas (las mismas que con Nginx) y terminaremos con una configuración un tanto más compleja. En todos los casos, ha de modificarse el archivo `/etc/haproxy/haproxy.cfg` y ha de reiniciarse el servicio con `service haproxy restart` para que los cambios surtan efecto.

#### Round-robin

La configuración anterior realiza el balanceo de carga con _round-robin_ (es la configuración por defecto, al igual que en el caso de Nginx).

#### Round-robin con ponderación

```
# ...

frontend http-in
    bind *:80
    default_backend balanceo_mianfg

backend balanceo_mianfg
    balance source
    hash-type consistent
    server m1    192.168.13.10:80    weight 1
    server m2    192.168.13.20:80    weight 2
```

![3-12](./img/3-12.png)

#### IP hashing

```
# ...

frontend http-in
    bind *:80
    default_backend balanceo_mianfg

backend balanceo_mianfg
    balance source
    hash-type consistent
    server m1    192.168.13.10:80
    server m2    192.168.13.20:80
```

![3-13](./img/3-13.png)

#### Keepalive timeout

Por defecto, HAProxy tiene configurado un timeout de acuerdo al protocolo HTTP. Más información en [este enlace](https://www.haproxy.com/blog/http-keep-alive-pipelining-multiplexing-and-connection-pooling/).

#### Marcar servidor como `down`

Marcamos como inactivo de nuevo a `m2` (SWAP2).

```
# ...

frontend http-in
    bind *:80
    default_backend balanceo_mianfg

backend balanceo_mianfg
    balance source
    hash-type consistent
    server m1    192.168.13.10:80
    server m2    192.168.13.20:80
```

![3-14](./img/3-14.png)

#### Una configuración más compleja

```
# ...

frontend http-in
    bind *:80
    default_backend balanceo_mianfg

backend balanceo_mianfg
    balance source
    hash-type consistent
    server m1    192.168.13.10:80    maxconn 32
    server m2    192.168.13.20:80    maxconn 32
    stick-table  type ip  size 1m  expire 1h
    stick on src
```

![3-15](./img/3-15.png)

* `maxconn` indica el número máximo de conexiones simultáneas, 32 tanto para SWAP1 como para SWAP2.
* `balance source` y `hash-type consistent` indican que estamos realizando IP hashing.
* Las dos últimas líneas de la configuración crearán una tabla en la memoria del balanceador de carga que mapea las direcciones IP con los servidores que las sirven. Es otra forma de ganar persistencia por IP. Los gastos de memoria son, sin embargo, muy bajos: 40MB por un millón de direcciones IPv4. `type ip` indica que se almacenarán las direcciones IP, `size 1m` indica que podrá almacenar un millón de direcciones, y `expire 1h` indica que la entrada expira tras 1h en memoria. `stick on src` indica que la asociación ocurrirá en el origen (_source_).

### Estadísticas de HAProxy

HAProxy tiene integrado un panel de estadísticas que puede ser visualizado mediante una interfaz web. Para habilitarlo, basta añadir la siguiente configuración a `/etc/haproxy/haproxy.cfg`:

```
global
    # ...
    stats socket /var/lib/haproxy/stats

listen stats
    bind *:1313
    mode http
    stats enable
    stats uri /stats
    stats realm HAProxy\ Statistics
    stats auth mianfg:password
```

![3-16](./img/3-16.png)

Reiniciamos el servicio y tendremos accesible el panel en `http://192.168.13.30/swap`. Deberemos introducir el usuario `mianfg` y la contraseña `password` para acceder.

![3-17](./img/3-17.png)

Vemos que todavía no hemos realizado ninguna petición (al reiniciar el servicio para aplicar la configuración se resetea la información).

#### Un primer vistazo

Vamos a echar un primer vistazo a las estadísticas, viendo el resultado de ejecutar `ab` con diversas configuraciones.

> Entraremos en profundidad en `ab` más adelante, pero me ha resultado interesante visualizar las estadísticas del panel en este momento.

Realizamos una serie de peticiones desde el host con `ab`, en concreto, usando:

```
mianfg@mianfg-msi$ ab -n 10000 -c 10 http://192.168.13.30/swap
```

Veremos qué ocurre con cada configuración de HAProxy.

##### Round-robin

Vemos cómo el reparto es perfecto: de las 10k peticiones, cada servidor recibe 5k.

![3-18](./img/3-18.png)

##### Round-robin con ponderación

Al darle una ponderación de 1 a SWAP1 (`m1`) y de 2 a SWAP2 (`m2`), vemos que 1/3 de las peticiones van a SWAP1 mientras que los 2/3 restantes van a SWAP2.

![3-19](./img/3-19.png)

##### IP hashing

Como el host tiene la misma IP, al realizar hashing por IP todas las peticiones se dirigirán a un mismo servidor, en nuestro caso, a SWAP1 (`m1`).

![3-20](./img/3-20.png)

##### Marcar un servidor como `down`

Vamos a realizar un experimento adicional: marcaremos un servidor como `down` (desactivaremos SWAP1, `m1`) **junto a** IP hashing. Vemos que el hashing se realiza entre las máquinas que están activas, dado que todas las peticiones van dirigidas al único servidor disponible. Además, vemos cómo la interfaz nos aclara que el servidor se encuentra en mantenimiento, tanto en la columna **Status** como coloreando la fila correspondiente.

![3-21](./img/3-21.png)

#### Configuración avanzada


### Go-between

### Zevenet

### Pound

## Carga a la granja web con `ab`

### Obtención de valores mediante Apache Benchmark

### Resultados y análisis

## Conclusiones
